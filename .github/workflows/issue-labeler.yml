name: Issue Auto Labeler

on:
  issues:
    types: [opened, edited]

jobs:
  label-issue:
    runs-on: ubuntu-latest
    permissions:
      issues: write

    steps:
      - name: Auto Label Issue
        uses: actions/github-script@v7
        with:
          script: |
            const { owner, repo } = context.repo;
            const issue = context.payload.issue;

            let labels = [];

            const title = issue.title.toLowerCase();
            const body = issue.body ? issue.body.toLowerCase() : '';
            const issueText = `${title} ${body}`;

            // ì´ìŠˆ íƒ€ì… ë¶„ë¥˜ í‚¤ì›Œë“œ
            const typeKeywords = {
              'bug': ['bug', 'error', 'issue', 'problem', 'broken', 'fail', 'crash', 'exception', 'ë²„ê·¸', 'ì˜¤ë¥˜', 'ì—ëŸ¬', 'ë¬¸ì œ'],
              'enhancement': ['feature', 'enhancement', 'improve', 'add', 'new', 'request', 'ê¸°ëŠ¥', 'ê°œì„ ', 'ì¶”ê°€', 'ìš”ì²­'],
              'documentation': ['doc', 'documentation', 'readme', 'guide', 'tutorial', 'ë¬¸ì„œ', 'ê°€ì´ë“œ', 'ì„¤ëª…'],
              'question': ['question', 'help', 'how', 'why', 'what', 'ì§ˆë¬¸', 'ë„ì›€', 'ì–´ë–»ê²Œ', 'ì™œ'],
              'testing': ['test', 'testing', 'spec', 'coverage', 'í…ŒìŠ¤íŠ¸', 'ê²€ì¦'],
              'performance': ['performance', 'slow', 'fast', 'optimize', 'speed', 'ì„±ëŠ¥', 'ìµœì í™”', 'ì†ë„'],
              'security': ['security', 'vulnerability', 'auth', 'permission', 'ë³´ì•ˆ', 'ì·¨ì•½ì ', 'ê¶Œí•œ']
            };

            // í‚¤ì›Œë“œ ê¸°ë°˜ ë¼ë²¨ë§
            for (const [label, keywords] of Object.entries(typeKeywords)) {
              if (keywords.some(keyword => issueText.includes(keyword))) {
                labels.push(label);
              }
            }

            // ì»´í¬ë„ŒíŠ¸ë³„ ë¼ë²¨ë§
            const componentKeywords = {
              'backend': ['api', 'server', 'database', 'backend', 'db', 'ë°±ì—”ë“œ', 'ì„œë²„', 'ë°ì´í„°ë² ì´ìŠ¤'],
              'frontend': ['ui', 'frontend', 'client', 'browser', 'css', 'html', 'javascript', 'í”„ë¡ íŠ¸ì—”ë“œ', 'ui', 'í™”ë©´'],
              'ci-cd': ['ci', 'cd', 'pipeline', 'deploy', 'build', 'github actions', 'ë°°í¬', 'ë¹Œë“œ'],
              'dependencies': ['dependency', 'package', 'npm', 'pip', 'requirements', 'ì˜ì¡´ì„±', 'íŒ¨í‚¤ì§€']
            };

            for (const [label, keywords] of Object.entries(componentKeywords)) {
              if (keywords.some(keyword => issueText.includes(keyword))) {
                labels.push(label);
              }
            }

            // ìš°ì„ ìˆœìœ„ ë¼ë²¨ë§
            const priorityKeywords = {
              'priority-critical': ['critical', 'urgent', 'emergency', 'production down', 'ê¸´ê¸‰', 'ì‹¬ê°', 'ì¤‘ìš”'],
              'priority-high': ['high priority', 'important', 'asap', 'soon', 'ë†’ì€ ìš°ì„ ìˆœìœ„'],
              'priority-low': ['low priority', 'minor', 'nice to have', 'ë‚®ì€ ìš°ì„ ìˆœìœ„', 'ë¶€ì°¨ì ']
            };

            for (const [label, keywords] of Object.entries(priorityKeywords)) {
              if (keywords.some(keyword => issueText.includes(keyword))) {
                labels.push(label);
              }
            }

            // ë‚œì´ë„ ë¼ë²¨ë§
            if (issueText.includes('beginner') || issueText.includes('easy') || issueText.includes('simple') || 
                issueText.includes('ì´ˆë³´') || issueText.includes('ì‰¬ìš´') || issueText.includes('ê°„ë‹¨')) {
              labels.push('good first issue');
            }

            if (issueText.includes('complex') || issueText.includes('difficult') || issueText.includes('advanced') ||
                issueText.includes('ë³µì¡') || issueText.includes('ì–´ë ¤ìš´') || issueText.includes('ê³ ê¸‰')) {
              labels.push('help wanted');
            }

            // ì´ìŠˆ ê¸¸ì´ì— ë”°ë¥¸ ë¼ë²¨ë§
            if (issue.body && issue.body.length > 1000) {
              labels.push('detailed');
            } else if (!issue.body || issue.body.length < 100) {
              labels.push('needs-info');
            }

            // íŠ¹ìˆ˜ ìƒí™© ë¼ë²¨ë§
            if (title.startsWith('[') && title.includes(']')) {
              labels.push('categorized');
            }

            if (issueText.includes('duplicate') || issueText.includes('ì¤‘ë³µ')) {
              labels.push('duplicate');
            }

            if (issueText.includes('wontfix') || issueText.includes('ìˆ˜ì • ì•ˆí•¨')) {
              labels.push('wontfix');
            }

            // ê¸°ë³¸ ë¼ë²¨ (ë¶„ë¥˜ë˜ì§€ ì•Šì€ ê²½ìš°)
            if (labels.length === 0) {
              labels.push('triage-needed');
            }

            // ì¤‘ë³µ ì œê±°
            labels = [...new Set(labels)];

            // ë¼ë²¨ ì ìš©
            if (labels.length > 0) {
              try {
                await github.rest.issues.addLabels({
                  owner,
                  repo,
                  issue_number: issue.number,
                  labels: labels
                });
                
                console.log(`Added labels: ${labels.join(', ')}`);
                
                // ë¼ë²¨ë§ ê²°ê³¼ ëŒ“ê¸€ ì‘ì„±
                const labelComment = `
                ğŸ·ï¸ **ìë™ ë¼ë²¨ë§ ì™„ë£Œ**
                
                ë‹¤ìŒ ë¼ë²¨ì´ ìë™ìœ¼ë¡œ ì¶”ê°€ë˜ì—ˆìŠµë‹ˆë‹¤: ${labels.map(l => `\`${l}\``).join(', ')}
                
                ë¼ë²¨ì´ ë¶€ì •í™•í•˜ë‹¤ë©´ ìˆ˜ë™ìœ¼ë¡œ ìˆ˜ì •í•´ì£¼ì„¸ìš”.
                `;
                
                await github.rest.issues.createComment({
                  owner,
                  repo,
                  issue_number: issue.number,
                  body: labelComment
                });
                
              } catch (error) {
                console.log(`Error adding labels: ${error.message}`);
              }
            }
